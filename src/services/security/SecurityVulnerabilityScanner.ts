export interface VulnerabilityCheck {
  id: string;
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: 'xss' | 'injection' | 'authentication' | 'authorization' | 'crypto' | 'configuration' | 'data-exposure';
  check: () => Promise<VulnerabilityResult> | VulnerabilityResult;
}

export interface VulnerabilityResult {
  passed: boolean;
  message: string;
  details?: Record<string, unknown>;
  recommendation?: string;
}

export interface ScanResult {
  id: string;
  timestamp: number;
  totalChecks: number;
  passedChecks: number;
  failedChecks: number;
  vulnerabilities: Array<{
    check: VulnerabilityCheck;
    result: VulnerabilityResult;
  }>;
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

class SecurityVulnerabilityScanner {
  private checks: VulnerabilityCheck[] = [];

  constructor() {
    this.initializeDefaultChecks();
  }

  private initializeDefaultChecks(): void {
    // XSS Protection Checks
    this.addCheck({
      id: 'csp-header',
      name: 'Content Security Policy',
      description: 'Check if CSP header is properly configured',
      severity: 'high',
      category: 'xss',
      check: () => {
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        const cspReportOnlyMeta = document.querySelector('meta[http-equiv="Content-Security-Policy-Report-Only"]');
        
        if (!cspMeta && !cspReportOnlyMeta) {
          return {
            passed: false,
            message: 'Content Security Policy not found',
            recommendation: 'Implement CSP headers to prevent XSS attacks'
          };
        }

        const cspContent = cspMeta?.getAttribute('content') || cspReportOnlyMeta?.getAttribute('content') || '';
        
        // Check for unsafe directives
        const unsafePatterns = ['unsafe-inline', 'unsafe-eval', '*'];
        const foundUnsafe = unsafePatterns.filter(pattern => cspContent.includes(pattern));
        
        if (foundUnsafe.length > 0) {
          return {
            passed: false,
            message: `CSP contains unsafe directives: ${foundUnsafe.join(', ')}`,
            details: { unsafeDirectives: foundUnsafe },
            recommendation: 'Remove unsafe CSP directives and use nonces or hashes instead'
          };
        }

        return {
          passed: true,
          message: 'Content Security Policy is properly configured'
        };
      }
    });

    // Authentication Checks
    this.addCheck({
      id: 'secure-storage',
      name: 'Secure Storage Usage',
      description: 'Check if sensitive data is stored securely',
      severity: 'critical',
      category: 'authentication',
      check: () => {
        const sensitiveKeys = ['password', 'token', 'key', 'secret', 'auth'];
        const foundSensitive: string[] = [];

        // Check localStorage
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
            foundSensitive.push(`localStorage: ${key}`);
          }
        }

        // Check sessionStorage
        for (let i = 0; i < sessionStorage.length; i++) {
          const key = sessionStorage.key(i);
          if (key && sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
            foundSensitive.push(`sessionStorage: ${key}`);
          }
        }

        if (foundSensitive.length > 0) {
          return {
            passed: false,
            message: 'Potentially sensitive data found in browser storage',
            details: { foundKeys: foundSensitive },
            recommendation: 'Use secure storage methods or encryption for sensitive data'
          };
        }

        return {
          passed: true,
          message: 'No sensitive data found in insecure storage'
        };
      }
    });

    // HTTPS Check
    this.addCheck({
      id: 'https-usage',
      name: 'HTTPS Usage',
      description: 'Check if application is served over HTTPS',
      severity: 'high',
      category: 'configuration',
      check: () => {
        const isHttps = window.location.protocol === 'https:';
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

        if (!isHttps && !isLocalhost) {
          return {
            passed: false,
            message: 'Application is not served over HTTPS',
            recommendation: 'Use HTTPS to encrypt data in transit'
          };
        }

        return {
          passed: true,
          message: 'Application is properly served over HTTPS or localhost'
        };
      }
    });

    // Mixed Content Check
    this.addCheck({
      id: 'mixed-content',
      name: 'Mixed Content',
      description: 'Check for mixed HTTP/HTTPS content',
      severity: 'medium',
      category: 'configuration',
      check: () => {
        const isHttps = window.location.protocol === 'https:';
        if (!isHttps) {
          return {
            passed: true,
            message: 'Not applicable - site not served over HTTPS'
          };
        }

        const httpResources: string[] = [];
        
        // Check images
        document.querySelectorAll('img[src^="http:"]').forEach(img => {
          httpResources.push(`Image: ${(img as HTMLImageElement).src}`);
        });

        // Check scripts
        document.querySelectorAll('script[src^="http:"]').forEach(script => {
          httpResources.push(`Script: ${(script as HTMLScriptElement).src}`);
        });

        // Check stylesheets
        document.querySelectorAll('link[href^="http:"]').forEach(link => {
          httpResources.push(`Stylesheet: ${(link as HTMLLinkElement).href}`);
        });

        if (httpResources.length > 0) {
          return {
            passed: false,
            message: 'Mixed content detected',
            details: { httpResources },
            recommendation: 'Use HTTPS URLs for all resources'
          };
        }

        return {
          passed: true,
          message: 'No mixed content detected'
        };
      }
    });

    // Cookie Security Check
    this.addCheck({
      id: 'cookie-security',
      name: 'Cookie Security',
      description: 'Check cookie security attributes',
      severity: 'medium',
      category: 'authentication',
      check: () => {
        const cookies = document.cookie.split(';');
        const insecureCookies: string[] = [];

        cookies.forEach(cookie => {
          const cookieName = cookie.split('=')[0]?.trim();
          if (cookieName) {
            // Note: We can't check HttpOnly, Secure, or SameSite from JavaScript
            // This is a limitation of client-side scanning
            const cookieValue = cookie.split('=')[1];
            if (cookieValue && cookieValue.length > 0) {
              insecureCookies.push(cookieName);
            }
          }
        });

        if (insecureCookies.length > 0) {
          return {
            passed: false,
            message: 'Cookies detected - ensure they have proper security attributes',
            details: { cookieNames: insecureCookies },
            recommendation: 'Set HttpOnly, Secure, and SameSite attributes on cookies'
          };
        }

        return {
          passed: true,
          message: 'No cookies detected or cookies are properly secured'
        };
      }
    });

    // DOM-based XSS Check
    this.addCheck({
      id: 'dom-xss',
      name: 'DOM-based XSS Prevention',
      description: 'Check for potential DOM-based XSS vulnerabilities',
      severity: 'high',
      category: 'xss',
      check: () => {
        const dangerousPatterns = [
          'innerHTML',
          'outerHTML',
          'document.write',
          'eval(',
          'setTimeout(',
          'setInterval('
        ];

        const scripts = Array.from(document.querySelectorAll('script'));
        const suspiciousCode: string[] = [];

        scripts.forEach((script, index) => {
          const scriptContent = script.textContent || script.innerHTML;
          dangerousPatterns.forEach(pattern => {
            if (scriptContent.includes(pattern)) {
              suspiciousCode.push(`Script ${index + 1}: contains ${pattern}`);
            }
          });
        });

        if (suspiciousCode.length > 0) {
          return {
            passed: false,
            message: 'Potentially dangerous DOM manipulation detected',
            details: { suspiciousCode },
            recommendation: 'Use safe DOM manipulation methods and validate all user input'
          };
        }

        return {
          passed: true,
          message: 'No dangerous DOM manipulation patterns detected'
        };
      }
    });

    // Information Disclosure Check
    this.addCheck({
      id: 'info-disclosure',
      name: 'Information Disclosure',
      description: 'Check for information disclosure in client-side code',
      severity: 'medium',
      category: 'data-exposure',
      check: () => {
        const sensitivePatterns = [
          /api[_-]?key/i,
          /secret/i,
          /password/i,
          /token/i,
          /private[_-]?key/i,
          /connection[_-]?string/i
        ];

        const scripts = Array.from(document.querySelectorAll('script'));
        const exposedInfo: string[] = [];

        scripts.forEach((script, index) => {
          const scriptContent = script.textContent || script.innerHTML;
          sensitivePatterns.forEach(pattern => {
            if (pattern.test(scriptContent)) {
              exposedInfo.push(`Script ${index + 1}: matches pattern ${pattern.source}`);
            }
          });
        });

        // Check global variables
        const globalVars = Object.keys(window);
        globalVars.forEach(varName => {
          sensitivePatterns.forEach(pattern => {
            if (pattern.test(varName)) {
              exposedInfo.push(`Global variable: ${varName}`);
            }
          });
        });

        if (exposedInfo.length > 0) {
          return {
            passed: false,
            message: 'Potential information disclosure detected',
            details: { exposedInfo },
            recommendation: 'Remove sensitive information from client-side code'
          };
        }

        return {
          passed: true,
          message: 'No sensitive information disclosure detected'
        };
      }
    });

    // Clickjacking Protection
    this.addCheck({
      id: 'clickjacking-protection',
      name: 'Clickjacking Protection',
      description: 'Check for X-Frame-Options or frame-ancestors CSP directive',
      severity: 'medium',
      category: 'configuration',
      check: () => {
        const xFrameOptions = document.querySelector('meta[http-equiv="X-Frame-Options"]');
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        const cspContent = cspMeta?.getAttribute('content') || '';
        
        const hasFrameAncestors = cspContent.includes('frame-ancestors');
        
        if (!xFrameOptions && !hasFrameAncestors) {
          return {
            passed: false,
            message: 'No clickjacking protection detected',
            recommendation: 'Set X-Frame-Options header or frame-ancestors CSP directive'
          };
        }

        return {
          passed: true,
          message: 'Clickjacking protection is configured'
        };
      }
    });
  }

  public addCheck(check: VulnerabilityCheck): void {
    this.checks.push(check);
  }

  public removeCheck(id: string): void {
    this.checks = this.checks.filter(check => check.id !== id);
  }

  public getChecks(): VulnerabilityCheck[] {
    return [...this.checks];
  }

  public async runScan(): Promise<ScanResult> {
    const scanId = `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const vulnerabilities: Array<{ check: VulnerabilityCheck; result: VulnerabilityResult }> = [];
    
    let passedChecks = 0;
    let failedChecks = 0;

    for (const check of this.checks) {
      try {
        const result = await Promise.resolve(check.check());
        
        if (result.passed) {
          passedChecks++;
        } else {
          failedChecks++;
          vulnerabilities.push({ check, result });
        }
      } catch (error) {
        failedChecks++;
        vulnerabilities.push({
          check,
          result: {
            passed: false,
            message: `Check failed with error: ${error}`,
            recommendation: 'Review the security check implementation'
          }
        });
      }
    }

    // Calculate risk summary
    const summary = {
      critical: vulnerabilities.filter(v => v.check.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.check.severity === 'high').length,
      medium: vulnerabilities.filter(v => v.check.severity === 'medium').length,
      low: vulnerabilities.filter(v => v.check.severity === 'low').length
    };

    // Determine overall risk
    let overallRisk: 'low' | 'medium' | 'high' | 'critical' = 'low';
    if (summary.critical > 0) {
      overallRisk = 'critical';
    } else if (summary.high > 0) {
      overallRisk = 'high';
    } else if (summary.medium > 0) {
      overallRisk = 'medium';
    }

    return {
      id: scanId,
      timestamp: Date.now(),
      totalChecks: this.checks.length,
      passedChecks,
      failedChecks,
      vulnerabilities,
      overallRisk,
      summary
    };
  }

  public async runSpecificChecks(checkIds: string[]): Promise<ScanResult> {
    const originalChecks = this.checks;
    this.checks = this.checks.filter(check => checkIds.includes(check.id));
    
    const result = await this.runScan();
    
    this.checks = originalChecks;
    return result;
  }

  public async runChecksByCategory(category: VulnerabilityCheck['category']): Promise<ScanResult> {
    const originalChecks = this.checks;
    this.checks = this.checks.filter(check => check.category === category);
    
    const result = await this.runScan();
    
    this.checks = originalChecks;
    return result;
  }

  public generateReport(scanResult: ScanResult): string {
    const report = {
      scanId: scanResult.id,
      timestamp: new Date(scanResult.timestamp).toISOString(),
      summary: {
        totalChecks: scanResult.totalChecks,
        passedChecks: scanResult.passedChecks,
        failedChecks: scanResult.failedChecks,
        overallRisk: scanResult.overallRisk
      },
      riskBreakdown: scanResult.summary,
      vulnerabilities: scanResult.vulnerabilities.map(v => ({
        id: v.check.id,
        name: v.check.name,
        description: v.check.description,
        severity: v.check.severity,
        category: v.check.category,
        message: v.result.message,
        recommendation: v.result.recommendation,
        details: v.result.details
      })),
      recommendations: this.generateRecommendations(scanResult)
    };

    return JSON.stringify(report, null, 2);
  }

  private generateRecommendations(scanResult: ScanResult): string[] {
    const recommendations: string[] = [];

    if (scanResult.summary.critical > 0) {
      recommendations.push('URGENT: Address critical security vulnerabilities immediately');
    }

    if (scanResult.summary.high > 0) {
      recommendations.push('High priority: Fix high-severity security issues');
    }

    if (scanResult.summary.medium > 0) {
      recommendations.push('Medium priority: Address medium-severity security concerns');
    }

    // Category-specific recommendations
    const categories = new Set(scanResult.vulnerabilities.map(v => v.check.category));
    
    if (categories.has('xss')) {
      recommendations.push('Implement comprehensive XSS protection measures');
    }
    
    if (categories.has('authentication')) {
      recommendations.push('Review authentication and session management practices');
    }
    
    if (categories.has('configuration')) {
      recommendations.push('Review security configuration and headers');
    }

    if (scanResult.failedChecks === 0) {
      recommendations.push('Great job! All security checks passed');
    }

    return recommendations;
  }

  public exportChecks(): string {
    return JSON.stringify({
      timestamp: Date.now(),
      checks: this.checks.map(check => ({
        id: check.id,
        name: check.name,
        description: check.description,
        severity: check.severity,
        category: check.category
      }))
    }, null, 2);
  }
}

export const securityVulnerabilityScanner = new SecurityVulnerabilityScanner();